
Brief Introduction to the Tsunami UDP Protocol and the Real-Time DAQ Extensions

The Tsunami protocol was created in 2002 by the Pervasive Technology Labs of Indiana University and was
released to the public as open-source under a UI Open Source License. After release, several people have 
improved the code and have added more functionality. Currently a generic and real-time version of the 
Tsunami UDP protocol are maintained by Metsähovi / Jan Wagner. Everyone interested is invited to join 
development at http://tsunami-udp.sf.net.

Tsunami is one of the several currently available UDP-based transfer protocols for high-speed transfer over high 
bandwidth-delay product network paths. Such paths are for example the route from a local server PC hookup to a 
local GEANT2 node such as FUNET or SURFNET, then via GEANT2's internal 10G to another country, and finally a 
local link via another node such as NORDUNET to some client PC. Currently typical rates are 1G..10G with some 
hundred milliseconds of roundtrip delay between client and server PCs.

Custom UDP protocols are needed as the usual TCP/IP is not very well suited for large bandwidth-delay product 
paths. To take full advantage of the available bandwidth, the standard slow-start TCP congestion control algorithm 
such as Reno would need to be replaced with for example the HighSpeed TCP algorithm or others, and several TCP 
parameters need to be tweaked such as enabling dynamic TCP window sizing. Most of these TCP extended features 
already part of in Windows Vista, but better and more extensive support and broader choice is found in Linux. 

In VLBI the data is often streamed, and there's no requirement for reliable transport as is guaranteed with TCP. 
In some cases, for example to maintain a high data stream throughput, it may be even better to just stream and not 
care about transmission errors i.e. not request retransmission of old missing data.

The Tsunami UDP protocol has several advantages over TCP and most other UDP-based similar protocols: it is 
high-speed (a maintained 900Mbps through 1Gbit NICs and switches isn't unusual), it offers data transmission with
default priority for data integrity, but may also be switched to rate priority by disabling retransmissions. 
It is the most stable of the other available UDP-based similar protocols. Tsunami is completely implemented in user land 
and thus doesn't depend on Linux kernel extensions. It can be compiled and run from a normal user account, even a 
guest account, and does not need root privileges. The settings for a file transfer are largely specified by
the client - this is useful since the Tsunami user often has a priori knowledge about the quality of their network 
connection and the speed of their harddisks, and can then pass suitable settings to the server via the Tsunami
client. Finally, the client already contains a command line interface so that no extra software is necessary. 
The client command line commands are similar to FTP commands.

How It Works

Tsunami performs a file transfer by sectioning the file into numbered blocks of usually 32kB size. Communication 
between the client and server applications flows over a low bandwidth TCP connection. The bulk data is transferred 
over UDP. 

Most of the protocol intelligence is worked into the client code - the server simply sends all requested 
blocks over UDP to the client. The client specifies nearly all parameters of the transfer such as the 
requested file name, target data rate, blocksize, target port, etc, and controls which blocks are requested
from the server and when they are requested. 

Transfers are initiated by the client. At the first stage stage of a transfer the client passes all parameters
to the server in a get-file request. The server reports back the length of the requested file in bytes, so the client 
can calculate how many blocks have to be received. 

The client requests blocks from the server in large batches i.e. not just one block at a time. To limit 
the transmission rate to the rate specified by the client, the server pauses for the correct amount of time before 
sending the next block. The client also regularly sends error rate information to the server. The server uses this
information to adjust the transmission rate; the server can gradually slow down the transmission when the client 
reports it is too slow in receiving and processing the UDP packets. The client configures the server's speed of slowdown 
and speedup/recovery, and what the acceptable packet loss percentage is, for example 7%. 

The client keeps track of which of the numbered blocks have already been received and which are still missing by
marking the received blocks into a simple bit field. When a block has been received, the bit corresponding to that 
block is set to '1' in the bit field. 

If the block number of a block received by the client is larger than what would be the correct and expected consecutive 
block, the missing intervening blocks are queued up for a pending retransmission. The retransmission "queue" is a simple 
sorted list of the missing block numbers. The list size is allowed to grow dynamically, to a limit. At regular intervals, 
the retransmission list is looked through, blocks that have been received in the meantime are removed from the list, and 
finally the list of missing blocks is sent as a normal block transmission request to the server. 

In the case that adding a new pending retransmission to the client's list makes the list exceed a hard-coded limit, the 
entire transfer is reinitiated to start at the first block in the list i.e. the earliest block in the entire file that 
has not been successfully received yet. This is done by sending a special restart-transmission request to the server.

When all blocks of the file have been successfully received, the client sends a terminate-transmission to the server.

Both the server and client regularly output a summary of transfer statistics to the console window during the transfer, 
reporting the target and actual rate, transmission error percentage, etc. The statistics can be used for example in
Matlab to graph the characteristics of the transfer.

How The Real-Time Tsunami Works

The real-time version of Tsunami works exactly the same way as the normal version. The main difference is
that instead of a "real" file the VSIB board block device /dev/vsib is opened for reading. This block device
supports all normal file operations such as read, write and seek. 

The kernel module of the VSIB board keeps a large ring buffer of VSI data in main memory, for example of 
128MB size. Data of the /dev/vsib block device is internally read from this memory buffer. In this sense the 
buffer contains a short term history of VSI data. At for example 512Mbit/s recording, a 128MB buffer would 
contain the last 128*8/512=2 seconds of 8-bit VSI data, or correspondingly 2s*(8/32)=0.5s of 32-bit VSI data.

When the client requests a file, instead of a "real" file name, the filename string now specifies the parameters 
for the VSIB recording. 

Since the VSIB block device appears externally to be of unlimited size (as the VSIB board samples the VSI connector 
continuously in time), the desired recording length in bytes has to be passed inside the filename. The filename is 
also parsed for an UTC encoded recording start time - the server will then wait until the specified time before 
reading and sending data. 

When the server is told to transmit a new block, it will read it from the VSIB block device with a read() and
send the complete data block to the client. Unlike in the "normal" server, the transmit rate is not limited
to some specified used value by doing short pauses in software. Instead the rate is automatically limited by 
the speed at which data is clocked into the VSIB board from the VSI connector, for example 512Mbit/s.

When the server is told to retransmit an old block, it is done exactly the same way as in the normal Tsunami
version. The VSIB block device is seek()'ed to the correct block and the data is read, thus the data comes from the
VSIB module's buffer i.e. the VSI data history (instead of a "real" file on a disk). The entire read data block is then sent
out the normal way as an UDP packet to the client. However, since past data is available immediately, for these old blocks 
the short pause in software is implemented, to limit the transmission rate and not flood the network connection.

Note that the current implementation of the real-time Tsunami server does not yet check if a requested block falls outside
of the time range of the available VSI data history. 

Since the transmission is in real-time at the rate that data comes in from the VSIB board, the receiving client side must be 
able to write to disk faster than at this real-time VSIB data rate. In addition, the VSIB driver buffer size on the 
server (configured in the kernel and passed to the VSIB module/driver) should be large enough to accomodate at least 0.5s of 
past data so that the usual short glitches present in any shared network connection e.g. over Internet do not cause data loss.




